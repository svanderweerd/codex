{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Introduction This is my digital garden . This is where I write. Keep track of my thoughts, be it lingering or active ones. Write down ideas, concepts and topics that interest me or that I might need in the future. In the past I've tried to take notes in a notebook, on my ipad, but also using third party applications such as Obsidian and Notion . Alas, as time passes, I find myself incapable of actively maintaining either one of them, or extract meaningful and longterm value from them. The personal notebook or Ipad notes become cluttered and unorganized, losing my motivation to use it as a personal library. Similar feelings arose when using Notion.so. Building comprehensive tables, code snippets, and referring to other pages often became a mess as well. I found that Obisidan grew on me - I even purschased a yearly subscription to support the developers. It has a steep learning curve, but eventually I got the hang of it. Unfortunately, this become somewhat difficult for me to maintain as well: it is self hosted on my laptop, which I don't all the time. Instead, I often work from devices that are provided by my clients, making it difficult to actively work in Obsidian. Additionally, I can't seem to use Obsidian for light-hearted topics such as fitness, or use it to put in my fleeting notes. I can't shake the feeling that I need to use Obsidian for academic grade documentation only, or use it to document advanced topics. This ultimately led me back to old school note taking, scattering my thoughts all over the place (Notion, Obsidian, physical notebooks, and Apple Notes). With digital garden, I embark on my next journey of collecting and maintaining my thoughts; a backup of my brains, so to speak. As Gwern put it: The goal of these pages is not to be a model of concision, maximizing entertainment value per word, or to preach to a choir by elegantly repeating a conclusion. Rather, I am attempting to explain things to my future self, who is intelligent and interested, but has forgotten. What I am doing is explaining why I decided what I did to myself and noting down everything I found interesting about it for future reference. I hope my other readers, whomever they may be, might find the topic as interesting as I found it, and the essay useful or at least entertaining\u2013but the intended audience is my future self. Principles Based on Gwern's long site principle . Heavily inspired by Lyz Digital Garden .","title":"Introduction"},{"location":"#introduction","text":"This is my digital garden . This is where I write. Keep track of my thoughts, be it lingering or active ones. Write down ideas, concepts and topics that interest me or that I might need in the future. In the past I've tried to take notes in a notebook, on my ipad, but also using third party applications such as Obsidian and Notion . Alas, as time passes, I find myself incapable of actively maintaining either one of them, or extract meaningful and longterm value from them. The personal notebook or Ipad notes become cluttered and unorganized, losing my motivation to use it as a personal library. Similar feelings arose when using Notion.so. Building comprehensive tables, code snippets, and referring to other pages often became a mess as well. I found that Obisidan grew on me - I even purschased a yearly subscription to support the developers. It has a steep learning curve, but eventually I got the hang of it. Unfortunately, this become somewhat difficult for me to maintain as well: it is self hosted on my laptop, which I don't all the time. Instead, I often work from devices that are provided by my clients, making it difficult to actively work in Obsidian. Additionally, I can't seem to use Obsidian for light-hearted topics such as fitness, or use it to put in my fleeting notes. I can't shake the feeling that I need to use Obsidian for academic grade documentation only, or use it to document advanced topics. This ultimately led me back to old school note taking, scattering my thoughts all over the place (Notion, Obsidian, physical notebooks, and Apple Notes). With digital garden, I embark on my next journey of collecting and maintaining my thoughts; a backup of my brains, so to speak. As Gwern put it: The goal of these pages is not to be a model of concision, maximizing entertainment value per word, or to preach to a choir by elegantly repeating a conclusion. Rather, I am attempting to explain things to my future self, who is intelligent and interested, but has forgotten. What I am doing is explaining why I decided what I did to myself and noting down everything I found interesting about it for future reference. I hope my other readers, whomever they may be, might find the topic as interesting as I found it, and the essay useful or at least entertaining\u2013but the intended audience is my future self.","title":"Introduction"},{"location":"#principles","text":"Based on Gwern's long site principle . Heavily inspired by Lyz Digital Garden .","title":"Principles"},{"location":"mkdocs/","text":"Welcome to MkDocs For full documentation visit mkdocs.org . Commands mkdocs new [dir-name] - Create a new project. mkdocs serve - Start the live-reloading docs server. mkdocs build - Build the documentation site. mkdocs -h - Print help message and exit. plugins used To setup my digital garden, I use the following mkdocs plugins: search : built-in MkDocs search plugin. If you use the Material theme, use search - Material instead of the built-in plugin minify : minify HTMLS, JS, CSS files prior to being written to disk integrating with Github pages If you want to have your documentation hosted on Github pages, you need to do the following steps in order to make it work: Create mkdocs site pip3 install mkdocs installs the mkdocs package to generate python based static sites. mkdocs new [site-name] creates a new project with the correct set-up. mkdocs build subsequently generates your static pages and places the files in /sites . Make sure to include this in your .gitignore file. Setting up a Python environment Here we explain how to set up a virtual environment using pyenv and use requirements.txt to keep track of our dependencies. Instead of using pyenv you can also directly start with Poetry. Further down this guide we explain the steps regarding a Poetry set up. setup a python environment ( pyenv virtualenv [environmentName] ) and activate it with pyenv activate [environmentName] . Install packages and plugins accordingly. Run pip freeze > requirements.txt to output your deps into requirements.txt . Add .venv to your .gitignore file. Host on gh pages Create a new repository in Github (empty one). Perform git init in your local mkdocs folder (the root folder that stores the mkdocs.yml file). The usual stuff (git add, git commit, git remote add origin [remote-url] and git push -u origin main). Now you need to perform the mkdocs gh-deploy command in your local mkdocs project. This creates a Git branch names gh-pages for Github Pages to pick up your site. Running this command will generate the static website. Rather than outputting the files in the site folder as we saw in the previous post, the website will be saved in a new branch named gh-pages and a push of this branch is done towards GitHub. If you go to the Actions tab on the GitHub repository, you will see GitHub automatically picking up the new gh-pages branch and deploying it to GitHub pages. Now your site is hosted on github pages accordingly. Everything has been setup! Automated deployments So far I have described how to manually deploy your mkdocs site to Github Pages. The next steps explain how you can do this automatically through Github Actions. Go to your Github repo and then to Actions menu. Click on New workflow and select the suggested workflow (simple workflow). This will generate a new file called blank.yml in the .github/workflows directory. See the example below for the changes that we conducted on the template file. I suggest to copy this over. Please be mindful of your default branch's name! If you have master , make sure to reflect that in the yaml file below as well. --- name: CI on: push: branches: [ \"main\" ] pull_request: branches: [ \"main\" ] # Allows you to run this workflow manually from the Actions tab workflow_dispatch: jobs: build: runs-on: ubuntu-latest steps: # Checks-out your repository under $GITHUB_WORKSPACE, so your job can access it - uses: actions/checkout@v3 with: fetch-depth: 0 - name: Set up python uses: actions/setup-python@v4 with: python-version: '3.10' - name: Install dependencies run: | python3 -m pip install --upgrade pip python3 -m pip install -r requirements.txt - name: Build site run: mkdocs gh-deploy --force --clean --verbose Change the file name to gh-pages.yml and make sure to commit this change to the default branch. Remember that the gh-pages branch will be generated by MkDocs, and we never want to either check out this branch locally or modify it manually. Now you have a minimal set-up for deploying your site through Github Actions automatically. The next steps refines our Github Workflow approach. These steps are not really needed if you don't want to. You can continue using pip3 with pyenv (or venv) for dependency and environment management, instead of poetry. You may also decide to add a Deploy job without integrating with Poetry all together. You simply change the yml file as follows: # I will not include the stuff that won't be changed - name: Build site run: mkdocs build --verbose # here I have updated the code from gh-deploy to build # When you replace gh-deploy, you need to add the step below in order to push the site to gh-pages: - name: Deploy uses: peaceiris/actions-gh-pages@v3 if: ${{ github.ref == 'refs/heads/main' }} with: deploy_key: ${{ secrets.ACTIONS_DEPLOY_KEY }} # ----- SEE NEXT SECTION FOR DEPLOYMENT KEYS! ----- publish_dir: ./site Refining Github Workflow After our first deployment, we do a git fetch and git pull in our local project. This will update our local folder and adds the newly created contents inside the .github directory. Before we use Poetry locally, we first need to make sure that we even have a Poetry environment and pyproject. toml file in our root directory. We run poetry init , and install the dependencies that are listed in our requirements.txt file. Now we tweak the gh-pages.yml file as follows: --- name: CI on: push: branches: [ \"main\" ] pull_request: branches: [ \"main\" ] # Allows you to run this workflow manually from the Actions tab workflow_dispatch: jobs: build: runs-on: ubuntu-latest steps: # Checks-out your repository under $GITHUB_WORKSPACE, so your job can access it - uses: actions/checkout@v3 with: fetch-depth: 0 - name: Set up python uses: actions/setup-python@v4 with: python-version: '3.10' - name: Install Poetry uses: snok/install-poetry@v1 with: virtualenvs-create: true virtualenvs-in-project: true installer-parallel: true - name: Load cached venv id: cached-poetry-dependencies uses: actions/cache@v3 with: path: .venv key: venv-${{ runner.os }}-${{ steps.setup-python.outputs.python-version }}-${{ hashFiles('**/poetry.lock') }} - name: Install dependencies if cache doesnt exist if: steps.cached-poetry-dependencies.outputs.cache-hit != 'true' run: poetry install --no-interaction --no-root - name: Install project run: poetry install --no-interaction --no-root - name: Make the site run: poetry run mkdocs build --verbose # run: poetry run mkdocs gh-deploy --force --clean --verbose - name: Deploy uses: peaceiris/actions-gh-pages@v3 if: ${{ github.ref == 'refs/heads/main' }} with: deploy_key: ${{ secrets.ACTIONS_DEPLOY_KEY }} publish_dir: ./site As shown above, we add a couple of jobs that take care of installing Poetry and our project dependencies. We also replace our run command in the Make the site job: we add poetry but also replace gh-deploy with build . Again, you may choose to keep poetry run mkdocs gh-deploy . Doing so, renders the job Deploy redundant. I suggest to remove that job accordingly. Since we are newly introducing Poetry to our pipeline, it might be good to first test if this is integrated correctly, and we don't experience any issues. If everything is fine, we can work on the next step. Deploy job Now that we don't use the gh-deploy functionality provided by MkDocs , we need to add another job that takes care of pushing our site to the gh-pages branch. That's where the Deploy job comes in. You'll notice the following parameter: deploy_key: ${{ secrets.ACTIONS_DEPLOY_KEY }} . Because we don't make use of the gh-deploy functionality, we need to make use of Github Runners : agents that are used to deploy code to certain environments. In our case, it is the gh-pages environment (i.e., branch). However, we need to properly authenticate the Runner otherwise it will not be able to perform write operations, thus deploying our site. To ensure that the Runner is able to authenticate, we make use of deploy keys and add them to our Github project. See the steps below for doing this: on your device, go to .ssh directory and run ssh-keygen -t ed25519 -C \"$(git config user.email)\" -f [ProjectName] -N \"\" . The [name] is the name that is used to write the public and private key files. I suggest to use the name of your project. This command generates a private and public key using the ed25519 algorithm. Go to your Github project settings > deploy keys and click on add deploy key title = Public key of ACTIONS_DEPLOY_KEY paste the contents of your [ProjectName].pub file into this field. This is your public key that you just generated. Go to Github project settings > Secrets > Actions and click on new repository secret secret name = ACTIONS_DEPLOY_KEY > you set this as title, since you refer to this variable name in your gh-pages.yml file ( deploy_key: ${{ secrets.ACTIONS_DEPLOY_KEY }} ) paste the contents of your [ProjectName] file in the .ssh folder. This is the private key that you just generated. Now you are all set. Now you can push your changes to your Github default branch. If there are no unexpected issues, Github will automatically deploy your changes to the Github Pages site, based on your workflow.","title":"Welcome to MkDocs"},{"location":"mkdocs/#welcome-to-mkdocs","text":"For full documentation visit mkdocs.org .","title":"Welcome to MkDocs"},{"location":"mkdocs/#commands","text":"mkdocs new [dir-name] - Create a new project. mkdocs serve - Start the live-reloading docs server. mkdocs build - Build the documentation site. mkdocs -h - Print help message and exit.","title":"Commands"},{"location":"mkdocs/#plugins-used","text":"To setup my digital garden, I use the following mkdocs plugins: search : built-in MkDocs search plugin. If you use the Material theme, use search - Material instead of the built-in plugin minify : minify HTMLS, JS, CSS files prior to being written to disk","title":"plugins used"},{"location":"mkdocs/#integrating-with-github-pages","text":"If you want to have your documentation hosted on Github pages, you need to do the following steps in order to make it work:","title":"integrating with Github pages"},{"location":"mkdocs/#create-mkdocs-site","text":"pip3 install mkdocs installs the mkdocs package to generate python based static sites. mkdocs new [site-name] creates a new project with the correct set-up. mkdocs build subsequently generates your static pages and places the files in /sites . Make sure to include this in your .gitignore file.","title":"Create mkdocs site"},{"location":"mkdocs/#setting-up-a-python-environment","text":"Here we explain how to set up a virtual environment using pyenv and use requirements.txt to keep track of our dependencies. Instead of using pyenv you can also directly start with Poetry. Further down this guide we explain the steps regarding a Poetry set up. setup a python environment ( pyenv virtualenv [environmentName] ) and activate it with pyenv activate [environmentName] . Install packages and plugins accordingly. Run pip freeze > requirements.txt to output your deps into requirements.txt . Add .venv to your .gitignore file.","title":"Setting up a Python environment"},{"location":"mkdocs/#host-on-gh-pages","text":"Create a new repository in Github (empty one). Perform git init in your local mkdocs folder (the root folder that stores the mkdocs.yml file). The usual stuff (git add, git commit, git remote add origin [remote-url] and git push -u origin main). Now you need to perform the mkdocs gh-deploy command in your local mkdocs project. This creates a Git branch names gh-pages for Github Pages to pick up your site. Running this command will generate the static website. Rather than outputting the files in the site folder as we saw in the previous post, the website will be saved in a new branch named gh-pages and a push of this branch is done towards GitHub. If you go to the Actions tab on the GitHub repository, you will see GitHub automatically picking up the new gh-pages branch and deploying it to GitHub pages. Now your site is hosted on github pages accordingly. Everything has been setup!","title":"Host on gh pages"},{"location":"mkdocs/#automated-deployments","text":"So far I have described how to manually deploy your mkdocs site to Github Pages. The next steps explain how you can do this automatically through Github Actions. Go to your Github repo and then to Actions menu. Click on New workflow and select the suggested workflow (simple workflow). This will generate a new file called blank.yml in the .github/workflows directory. See the example below for the changes that we conducted on the template file. I suggest to copy this over. Please be mindful of your default branch's name! If you have master , make sure to reflect that in the yaml file below as well. --- name: CI on: push: branches: [ \"main\" ] pull_request: branches: [ \"main\" ] # Allows you to run this workflow manually from the Actions tab workflow_dispatch: jobs: build: runs-on: ubuntu-latest steps: # Checks-out your repository under $GITHUB_WORKSPACE, so your job can access it - uses: actions/checkout@v3 with: fetch-depth: 0 - name: Set up python uses: actions/setup-python@v4 with: python-version: '3.10' - name: Install dependencies run: | python3 -m pip install --upgrade pip python3 -m pip install -r requirements.txt - name: Build site run: mkdocs gh-deploy --force --clean --verbose Change the file name to gh-pages.yml and make sure to commit this change to the default branch. Remember that the gh-pages branch will be generated by MkDocs, and we never want to either check out this branch locally or modify it manually. Now you have a minimal set-up for deploying your site through Github Actions automatically. The next steps refines our Github Workflow approach. These steps are not really needed if you don't want to. You can continue using pip3 with pyenv (or venv) for dependency and environment management, instead of poetry. You may also decide to add a Deploy job without integrating with Poetry all together. You simply change the yml file as follows: # I will not include the stuff that won't be changed - name: Build site run: mkdocs build --verbose # here I have updated the code from gh-deploy to build # When you replace gh-deploy, you need to add the step below in order to push the site to gh-pages: - name: Deploy uses: peaceiris/actions-gh-pages@v3 if: ${{ github.ref == 'refs/heads/main' }} with: deploy_key: ${{ secrets.ACTIONS_DEPLOY_KEY }} # ----- SEE NEXT SECTION FOR DEPLOYMENT KEYS! ----- publish_dir: ./site","title":"Automated deployments"},{"location":"mkdocs/#refining-github-workflow","text":"After our first deployment, we do a git fetch and git pull in our local project. This will update our local folder and adds the newly created contents inside the .github directory. Before we use Poetry locally, we first need to make sure that we even have a Poetry environment and pyproject. toml file in our root directory. We run poetry init , and install the dependencies that are listed in our requirements.txt file. Now we tweak the gh-pages.yml file as follows: --- name: CI on: push: branches: [ \"main\" ] pull_request: branches: [ \"main\" ] # Allows you to run this workflow manually from the Actions tab workflow_dispatch: jobs: build: runs-on: ubuntu-latest steps: # Checks-out your repository under $GITHUB_WORKSPACE, so your job can access it - uses: actions/checkout@v3 with: fetch-depth: 0 - name: Set up python uses: actions/setup-python@v4 with: python-version: '3.10' - name: Install Poetry uses: snok/install-poetry@v1 with: virtualenvs-create: true virtualenvs-in-project: true installer-parallel: true - name: Load cached venv id: cached-poetry-dependencies uses: actions/cache@v3 with: path: .venv key: venv-${{ runner.os }}-${{ steps.setup-python.outputs.python-version }}-${{ hashFiles('**/poetry.lock') }} - name: Install dependencies if cache doesnt exist if: steps.cached-poetry-dependencies.outputs.cache-hit != 'true' run: poetry install --no-interaction --no-root - name: Install project run: poetry install --no-interaction --no-root - name: Make the site run: poetry run mkdocs build --verbose # run: poetry run mkdocs gh-deploy --force --clean --verbose - name: Deploy uses: peaceiris/actions-gh-pages@v3 if: ${{ github.ref == 'refs/heads/main' }} with: deploy_key: ${{ secrets.ACTIONS_DEPLOY_KEY }} publish_dir: ./site As shown above, we add a couple of jobs that take care of installing Poetry and our project dependencies. We also replace our run command in the Make the site job: we add poetry but also replace gh-deploy with build . Again, you may choose to keep poetry run mkdocs gh-deploy . Doing so, renders the job Deploy redundant. I suggest to remove that job accordingly. Since we are newly introducing Poetry to our pipeline, it might be good to first test if this is integrated correctly, and we don't experience any issues. If everything is fine, we can work on the next step.","title":"Refining Github Workflow"},{"location":"mkdocs/#deploy-job","text":"Now that we don't use the gh-deploy functionality provided by MkDocs , we need to add another job that takes care of pushing our site to the gh-pages branch. That's where the Deploy job comes in. You'll notice the following parameter: deploy_key: ${{ secrets.ACTIONS_DEPLOY_KEY }} . Because we don't make use of the gh-deploy functionality, we need to make use of Github Runners : agents that are used to deploy code to certain environments. In our case, it is the gh-pages environment (i.e., branch). However, we need to properly authenticate the Runner otherwise it will not be able to perform write operations, thus deploying our site. To ensure that the Runner is able to authenticate, we make use of deploy keys and add them to our Github project. See the steps below for doing this: on your device, go to .ssh directory and run ssh-keygen -t ed25519 -C \"$(git config user.email)\" -f [ProjectName] -N \"\" . The [name] is the name that is used to write the public and private key files. I suggest to use the name of your project. This command generates a private and public key using the ed25519 algorithm. Go to your Github project settings > deploy keys and click on add deploy key title = Public key of ACTIONS_DEPLOY_KEY paste the contents of your [ProjectName].pub file into this field. This is your public key that you just generated. Go to Github project settings > Secrets > Actions and click on new repository secret secret name = ACTIONS_DEPLOY_KEY > you set this as title, since you refer to this variable name in your gh-pages.yml file ( deploy_key: ${{ secrets.ACTIONS_DEPLOY_KEY }} ) paste the contents of your [ProjectName] file in the .ssh folder. This is the private key that you just generated. Now you are all set. Now you can push your changes to your Github default branch. If there are no unexpected issues, Github will automatically deploy your changes to the Github Pages site, based on your workflow.","title":"Deploy job"},{"location":"python-setup/","text":"pip pip freeze > requirements.txt outputs your packages into requirements.txt. poetry shell creates a new poetry environment. poetry run allows you to run package commands inside your poetry environment.","title":"pip"},{"location":"python-setup/#pip","text":"pip freeze > requirements.txt outputs your packages into requirements.txt. poetry shell creates a new poetry environment. poetry run allows you to run package commands inside your poetry environment.","title":"pip"}]}